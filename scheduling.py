import pandas as pd
import random
from itertools import combinations


def get_archive_of_matchups(past_matches: pd.DataFrame,
                            pool: list
                            ) -> pd.DataFrame:
    """
    Calculates how many teams each pair of available players has played before.
    :param past_matches: Table with all past matches
    :param pool: List of all available players this week
    :return: Table with all possible matchups and cunt of how many times they played before
    """

    # Filter matches where both players are in the pool
    filtered_df = past_matches[past_matches['player 1'].isin(pool) & past_matches['player 2'].isin(pool)].copy()

    # Create a normalized pair column to avoid order issues
    filtered_df['matchup'] = None
    for idx in filtered_df.index:
        row = filtered_df.loc[idx, :]
        filtered_df.at[idx, 'matchup'] = tuple(sorted([row['player 1'], row['player 2']]))

    # Count occurrences of each match-up
    match_counts = filtered_df['matchup'].value_counts().to_dict()

    # Generate all possible matchups
    all_matchups = {tuple(sorted(pair)): 0 for pair in combinations(pool, 2)}

    # Merge counts with all possible matchups
    for matchup, count in match_counts.items():
        all_matchups[matchup] = count

    # Convert to DataFrame
    result_df = pd.DataFrame(list(all_matchups.items()), columns=['matchup', 'count'])

    return result_df


def pick_next_matchups(match_count: pd.DataFrame,
                       pool: list,
                       ranking: pd.DataFrame
                       ) -> tuple[list, str]:
    """
    Select current week's matches trying to minimise match-up repetition.
    If odd numbers, player with most games rests
    :param match_count: Table of previous match ups generated by get_archive_of_matchups
    :param pool: List of all available players this week
    :param ranking: Table with ranking, which also has number of games played by each player
    :return: List of match ups and string with name of player resting
    """
    # Make sure there's no repetition in pool
    available_players = set(pool)
    match_count = match_count.sort_values('count')
    next_matchups = []

    # Check if odd number of players. One player will need to rest, ideally the one with most games played
    if len(available_players) % 2 != 0:
        # Check if any of players already in ranking
        if len(available_players.intersection(set(ranking['player']))) > 0:
            # Filter by players already in ranking
            filtered_df = ranking[ranking['player'].isin(available_players)]
            odd_player =  filtered_df.loc[filtered_df['games_played'].idxmax(), 'player']
        else:
            odd_player = random.choice(list(available_players))

        available_players.remove(odd_player)
    else:
        odd_player = ""

    for matchup in match_count['matchup']:
        if matchup[0] in available_players and matchup[1] in available_players:
            next_matchups.append(matchup)
            available_players.remove(matchup[0])
            available_players.remove(matchup[1])

        if len(available_players) <= 1:
            break  # Stop if we have an odd player left out

    return next_matchups, odd_player


def create_matchup_table(matchups: list
                         ) -> pd.DataFrame:
    """
    Convert list of matchups (tuples) to a df.
    """

    df = pd.DataFrame(
        columns=['player 1', 'player 2', 'score 1', 'score 2']
    )
    for pair in matchups:
        df.loc[len(df), ['player 1', 'player 2', 'score 1', 'score 2']] = \
            [pair[0], pair[1], '', '']

    return df


def generate_sign_up_table(ranks: pd.DataFrame,
                           pool: list
                           ) -> pd.DataFrame:
    """
    Generates a table with all players that have ever signed up, to use as next sign up table.
    :param ranks: Table with rankings
    :param pool: List of all available players this week
    :return: Table with all players that have ever signed up
    """

    all_players = list(set(list(ranks['player']) + list(pool)))
    signup_df = pd.DataFrame()
    signup_df['player'] = all_players
    signup_df['playing'] = ''

    signup_df = signup_df.sort_values('player')

    return signup_df
